{"version":3,"sources":["webpack:///./src/features/DeFiZap/DeFiZapFlow.tsx","webpack:///./src/features/DeFiZap/ZapStepper.tsx","webpack:///./src/features/DeFiZap/stateFactory.tsx"],"names":["withRouter","match","zapName","zapId","params","selectedZap","ZAPS_CONFIG","undefined","zapFlowState","handleUserInputFormSubmit","handleTxSigned","useStateReducer","ZapInteractionFactory","zapSelected","txConfig","txReceipt","steps","label","translateRaw","component","ZapForm","props","actions","formData","cb","ZapConfirm","SignTransaction","payload","ZapReceipt","defaultBackPath","ROUTE_PATHS","DEFIZAP","path","defaultBackPathLabel","title","completeBtnText","state","setState","addTxToAccount","useAccounts","getNetworkById","useNetworks","rawTransaction","makeTxFromForm","address","contractAddress","gasLimit","minimumGasLimit","inputValueToHex","amount","senderAccount","account","receiverAddress","networkId","network","id","asset","baseAsset","from","async","signResponse","isWeb3Wallet","wallet","hash","to","txType","ITxType","status","ITxStatus","PENDING","prevState","ProviderHandler","sendRawTx","then","txResponse","catch","txHash","pendingTxReceipt","makePendingTxReceipt"],"mappings":"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","file":"DeFiZapFlow.91dcc805edbbf7d363a2.js","sourcesContent":["import { withRouter } from 'react-router-dom';\n\nimport ZapEducation from './components/ZapSelection';\nimport { IZapConfig, IZapId, ZAPS_CONFIG } from './config';\nimport ZapStepper from './ZapStepper';\n\nconst DeFiZapFlow = withRouter(({ match }) => {\n  const { zapName: zapId } = match.params;\n  const selectedZap: IZapConfig | undefined = zapId ? ZAPS_CONFIG[zapId as IZapId] : undefined;\n\n  return <>{selectedZap ? <ZapStepper selectedZap={selectedZap} /> : <ZapEducation />}</>;\n});\n\nexport default DeFiZapFlow;\n","import { default as GeneralStepper, IStepperPath } from '@components/GeneralStepper';\nimport { ROUTE_PATHS } from '@config';\nimport SignTransaction from '@features/SendAssets/components/SignTransaction';\nimport { translateRaw } from '@translations';\nimport { ISignedTx, ISimpleTxFormFull, ITxReceipt } from '@types';\nimport { useStateReducer } from '@utils';\n\nimport ZapConfirm from './components/ZapConfirm';\nimport ZapForm from './components/ZapForm';\nimport ZapReceipt from './components/ZapReceipt';\nimport { IZapConfig } from './config';\nimport ZapInteractionFactory from './stateFactory';\n\nconst initialZapFlowState = (initialZapSelected: IZapConfig) => ({\n  zapSelected: initialZapSelected,\n  txConfig: undefined,\n  txReceipt: undefined\n});\n\ninterface Props {\n  selectedZap: IZapConfig;\n}\n\nconst ZapStepper = ({ selectedZap }: Props) => {\n  const { zapFlowState, handleUserInputFormSubmit, handleTxSigned } = useStateReducer(\n    ZapInteractionFactory,\n    initialZapFlowState(selectedZap)\n  );\n\n  const steps: IStepperPath[] = [\n    {\n      label: translateRaw('ZAP_FLOW_ADD_FUNDS'),\n      component: ZapForm,\n      props: ((state) => state)(zapFlowState),\n      actions: (formData: ISimpleTxFormFull, cb: any) => handleUserInputFormSubmit(formData, cb)\n    },\n    {\n      label: translateRaw('CONFIRM_TRANSACTION'),\n      component: ZapConfirm,\n      props: (({ txConfig, zapSelected }) => ({ txConfig, zapSelected }))(zapFlowState)\n    },\n    {\n      label: '',\n      component: SignTransaction,\n      props: (({ txConfig }) => ({ txConfig }))(zapFlowState),\n      actions: (payload: ITxReceipt | ISignedTx, cb: any) => handleTxSigned(payload, cb)\n    },\n    {\n      label: translateRaw('BROADCAST_TX_RECEIPT_TITLE'),\n      component: ZapReceipt,\n      props: (({ txConfig, zapSelected, txReceipt }) => ({ txConfig, zapSelected, txReceipt }))(\n        zapFlowState\n      )\n    }\n  ];\n  return (\n    <GeneralStepper\n      steps={steps}\n      defaultBackPath={ROUTE_PATHS.DEFIZAP.path}\n      defaultBackPathLabel={ROUTE_PATHS.DEFIZAP.title}\n      completeBtnText={translateRaw('SEND_ASSETS_SEND_ANOTHER')}\n    />\n  );\n};\nexport default ZapStepper;\n","import { makePendingTxReceipt, makeTxFromForm } from '@helpers';\nimport { useAccounts, useNetworks } from '@services';\nimport { ProviderHandler } from '@services/EthService';\nimport {\n  Asset,\n  ISimpleTxFormFull,\n  ITxConfig,\n  ITxData,\n  ITxHash,\n  ITxStatus,\n  ITxType,\n  TAddress,\n  TStepAction\n} from '@types';\nimport { inputValueToHex, isWeb3Wallet, TUseStateReducerFactory } from '@utils';\n\nimport { ZapInteractionState } from './types';\n\nconst ZapInteractionFactory: TUseStateReducerFactory<ZapInteractionState> = ({\n  state,\n  setState\n}) => {\n  const { addTxToAccount } = useAccounts();\n  const { getNetworkById } = useNetworks();\n\n  const handleTxSigned = async (signResponse: any, cb: any) => {\n    const { txConfig } = state;\n    if (!txConfig.senderAccount) return;\n\n    if (isWeb3Wallet(txConfig.senderAccount.wallet)) {\n      const txReceipt =\n        signResponse && signResponse.hash\n          ? signResponse\n          : { hash: signResponse, asset: txConfig.asset };\n      addTxToAccount(state.txConfig.senderAccount, {\n        ...txReceipt,\n        to: state.txConfig.receiverAddress,\n        from: state.txConfig.senderAccount.address,\n        amount: state.txConfig.amount,\n        txType: ITxType.DEFIZAP,\n        status: ITxStatus.PENDING\n      });\n      setState((prevState: ZapInteractionState) => ({\n        ...prevState,\n        txReceipt\n      }));\n      cb();\n    } else {\n      const provider = new ProviderHandler(getNetworkById(txConfig.networkId));\n      provider\n        .sendRawTx(signResponse)\n        .then((txResponse) => txResponse.hash as ITxHash)\n        .catch((hash) => hash as ITxHash)\n        .then((txHash) => {\n          const pendingTxReceipt = makePendingTxReceipt(txHash)(ITxType.DEFIZAP, txConfig);\n          addTxToAccount(state.txConfig.senderAccount, pendingTxReceipt);\n          setState((prevState: ZapInteractionState) => ({\n            ...prevState,\n            txReceipt: pendingTxReceipt\n          }));\n          cb();\n        });\n    }\n  };\n\n  const handleUserInputFormSubmit: TStepAction = (payload: ISimpleTxFormFull, cb: any) => {\n    const rawTransaction = makeTxFromForm(\n      {\n        ...payload,\n        address: state.zapSelected!.contractAddress,\n        gasLimit: state.zapSelected!.minimumGasLimit\n      },\n      inputValueToHex(payload.amount),\n      '0x' as ITxData\n    );\n\n    const txConfig: ITxConfig = {\n      rawTransaction,\n      amount: payload.amount,\n      senderAccount: payload.account,\n      receiverAddress: state.zapSelected!.contractAddress as TAddress,\n      networkId: payload.network.id,\n      asset: payload.asset,\n      baseAsset: payload.asset || ({} as Asset),\n      from: payload.account.address\n    };\n    setState({\n      ...state,\n      txConfig\n    });\n    cb();\n  };\n\n  return {\n    handleUserInputFormSubmit,\n    handleTxSigned,\n    zapFlowState: state\n  };\n};\n\nexport default ZapInteractionFactory;\n"],"sourceRoot":""}